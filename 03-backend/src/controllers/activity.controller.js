const { PrismaClient } = require('@prisma/client');
const calculationService = require('../services/calculation.service');

const prisma = new PrismaClient();

/**
 * Generate activities for a project using the calculation engine
 */
const generateActivities = async (req, res, next) => {
  try {
    const { id: projectId } = req.params;

    // Verify project exists and belongs to user
    const project = await prisma.project.findFirst({
      where: { id: projectId, userId: req.user.id },
      include: {
        technicalParameters: true,
        projectScopes: {
          where: { isSelected: true },
          include: { scopeType: true }
        }
      }
    });

    if (!project) {
      return res.status(404).json({
        error: 'Not Found',
        message: 'Project not found'
      });
    }

    if (!project.technicalParameters) {
      return res.status(400).json({
        error: 'Missing Data',
        message: 'Technical parameters must be saved before generating activities'
      });
    }

    // Delete existing auto-generated activities
    await prisma.activity.deleteMany({
      where: {
        projectId,
        isAutoGenerated: true
      }
    });

    // Generate activities using the calculation engine
    const activities = await calculationService.generateActivities(project);

    // Calculate and update project totals
    const totalHours = activities.reduce((sum, a) => sum + parseFloat(a.totalHours), 0);
    await prisma.project.update({
      where: { id: projectId },
      data: { totalEstimatedHours: totalHours }
    });

    res.json({
      message: `Generated ${activities.length} activities`,
      count: activities.length,
      totalHours,
      activities
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Get all activities for a project
 */
const getActivities = async (req, res, next) => {
  try {
    const { id: projectId } = req.params;

    // Verify project belongs to user
    const project = await prisma.project.findFirst({
      where: { id: projectId, userId: req.user.id }
    });

    if (!project) {
      return res.status(404).json({
        error: 'Not Found',
        message: 'Project not found'
      });
    }

    const activities = await prisma.activity.findMany({
      where: { projectId },
      orderBy: { displayOrder: 'asc' },
      include: {
        weldingProcess: true
      }
    });

    const totalHours = activities.reduce((sum, a) => sum + parseFloat(a.totalHours), 0);

    res.json({
      count: activities.length,
      totalHours,
      activities
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Update a single activity
 */
const updateActivity = async (req, res, next) => {
  try {
    const { activityId } = req.params;
    const { difficultyFactor, efficiencyFactor, crewSize, manualOverrideHours, notes } = req.body;

    // Get activity and verify project ownership
    const activity = await prisma.activity.findFirst({
      where: { id: activityId },
      include: { project: true }
    });

    if (!activity || activity.project.userId !== req.user.id) {
      return res.status(404).json({
        error: 'Not Found',
        message: 'Activity not found'
      });
    }

    // Calculate new total hours
    let totalHours;
    let isManualEdit = activity.isManualEdit;

    if (manualOverrideHours !== undefined && manualOverrideHours !== null) {
      totalHours = manualOverrideHours;
      isManualEdit = true;
    } else {
      const diff = difficultyFactor !== undefined ? difficultyFactor : activity.difficultyFactor;
      const eff = efficiencyFactor !== undefined ? efficiencyFactor : activity.efficiencyFactor;
      totalHours = (parseFloat(activity.baseHours) * parseFloat(activity.quantity) * parseFloat(diff)) / parseFloat(eff);
      isManualEdit = false;
    }

    // Calculate duration
    const crew = crewSize || activity.crewSize;
    const durationDays = totalHours / (crew * 8);

    const updatedActivity = await prisma.activity.update({
      where: { id: activityId },
      data: {
        difficultyFactor: difficultyFactor !== undefined ? difficultyFactor : activity.difficultyFactor,
        efficiencyFactor: efficiencyFactor !== undefined ? efficiencyFactor : activity.efficiencyFactor,
        crewSize: crew,
        manualOverrideHours: manualOverrideHours !== undefined ? manualOverrideHours : null,
        totalHours,
        durationDays,
        notes: notes !== undefined ? notes : activity.notes,
        isManualEdit
      }
    });

    // Recalculate project totals
    await recalculateProjectTotals(activity.projectId);

    res.json({
      message: 'Activity updated successfully',
      activity: updatedActivity
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Bulk update activities
 */
const bulkUpdateActivities = async (req, res, next) => {
  try {
    const { projectId } = req.params;
    const { activityUpdates } = req.body;

    // Verify project belongs to user
    const project = await prisma.project.findFirst({
      where: { id: projectId, userId: req.user.id }
    });

    if (!project) {
      return res.status(404).json({
        error: 'Not Found',
        message: 'Project not found'
      });
    }

    const updatedActivities = [];

    for (const update of activityUpdates) {
      const { activityId, ...updates } = update;

      const activity = await prisma.activity.findFirst({
        where: { id: activityId, projectId }
      });

      if (!activity) continue;

      // Calculate new values
      let totalHours;
      let isManualEdit = activity.isManualEdit;

      if (updates.manualOverrideHours !== undefined && updates.manualOverrideHours !== null) {
        totalHours = updates.manualOverrideHours;
        isManualEdit = true;
      } else {
        const diff = updates.difficultyFactor !== undefined ? updates.difficultyFactor : activity.difficultyFactor;
        const eff = updates.efficiencyFactor !== undefined ? updates.efficiencyFactor : activity.efficiencyFactor;
        totalHours = (parseFloat(activity.baseHours) * parseFloat(activity.quantity) * parseFloat(diff)) / parseFloat(eff);
        isManualEdit = false;
      }

      const crew = updates.crewSize || activity.crewSize;
      const durationDays = totalHours / (crew * 8);

      const updated = await prisma.activity.update({
        where: { id: activityId },
        data: {
          difficultyFactor: updates.difficultyFactor !== undefined ? updates.difficultyFactor : activity.difficultyFactor,
          efficiencyFactor: updates.efficiencyFactor !== undefined ? updates.efficiencyFactor : activity.efficiencyFactor,
          crewSize: crew,
          manualOverrideHours: updates.manualOverrideHours !== undefined ? updates.manualOverrideHours : null,
          totalHours,
          durationDays,
          notes: updates.notes !== undefined ? updates.notes : activity.notes,
          isManualEdit
        }
      });

      updatedActivities.push(updated);
    }

    // Recalculate project totals
    const totals = await recalculateProjectTotals(projectId);

    res.json({
      message: `Updated ${updatedActivities.length} activities`,
      count: updatedActivities.length,
      totalHours: totals.totalHours,
      activities: updatedActivities
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Add manual activity
 */
const addManualActivity = async (req, res, next) => {
  try {
    const { projectId } = req.params;
    const activityData = req.body;

    // Verify project belongs to user
    const project = await prisma.project.findFirst({
      where: { id: projectId, userId: req.user.id }
    });

    if (!project) {
      return res.status(404).json({
        error: 'Not Found',
        message: 'Project not found'
      });
    }

    // Get max display order
    const maxOrder = await prisma.activity.findFirst({
      where: { projectId },
      orderBy: { displayOrder: 'desc' },
      select: { displayOrder: true }
    });

    const totalHours = (activityData.baseHours * activityData.quantity * activityData.difficultyFactor) / activityData.efficiencyFactor;
    const durationDays = totalHours / (activityData.crewSize * 8);

    const activity = await prisma.activity.create({
      data: {
        projectId,
        activityCode: activityData.activityCode,
        description: activityData.description,
        scopeTypeCode: activityData.scopeTypeCode,
        quantity: activityData.quantity,
        unit: activityData.unit,
        baseHours: activityData.baseHours,
        difficultyFactor: activityData.difficultyFactor,
        efficiencyFactor: activityData.efficiencyFactor,
        totalHours,
        weldingProcessCode: activityData.weldingProcessCode,
        crewSize: activityData.crewSize,
        durationDays,
        isAutoGenerated: false,
        isManualEdit: true,
        notes: activityData.notes,
        displayOrder: (maxOrder?.displayOrder || 0) + 1
      }
    });

    // Recalculate project totals
    await recalculateProjectTotals(projectId);

    res.status(201).json({
      message: 'Activity added successfully',
      activity
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Delete activity
 */
const deleteActivity = async (req, res, next) => {
  try {
    const { activityId } = req.params;

    const activity = await prisma.activity.findFirst({
      where: { id: activityId },
      include: { project: true }
    });

    if (!activity || activity.project.userId !== req.user.id) {
      return res.status(404).json({
        error: 'Not Found',
        message: 'Activity not found'
      });
    }

    await prisma.activity.delete({
      where: { id: activityId }
    });

    // Recalculate project totals
    await recalculateProjectTotals(activity.projectId);

    res.json({
      message: 'Activity deleted successfully'
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Recalculate project totals
 */
async function recalculateProjectTotals(projectId) {
  const activities = await prisma.activity.findMany({
    where: { projectId }
  });

  const totalHours = activities.reduce((sum, a) => sum + parseFloat(a.totalHours), 0);

  await prisma.project.update({
    where: { id: projectId },
    data: { totalEstimatedHours: totalHours }
  });

  return { totalHours, activityCount: activities.length };
}

module.exports = {
  generateActivities,
  getActivities,
  updateActivity,
  bulkUpdateActivities,
  addManualActivity,
  deleteActivity
};
