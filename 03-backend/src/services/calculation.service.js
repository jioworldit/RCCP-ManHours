const { PrismaClient, ActivityUnit } = require('@prisma/client');

const prisma = new PrismaClient();

/**
 * Generate activities for a project based on technical parameters and scope selections
 */
async function generateActivities(project) {
  const activities = [];
  const techParams = project.technicalParameters;
  const selectedScopes = project.projectScopes;

  // Get material grade for multipliers
  const materialGrade = await prisma.materialGrade.findFirst({
    where: { gradeCode: techParams.materialGrade }
  });

  const materialFactors = materialGrade || {
    cuttingFactor: 1.0,
    fitupFactor: 1.0,
    weldingFactor: 1.0,
    ndtFactor: 1.0,
    category: 'CS'
  };

  // Build parameter dictionary for formulas
  const params = {
    thickness_mm: parseFloat(techParams.shellThicknessMm || 10),
    diameter_mm: parseFloat(techParams.diameterMm || 1000),
    length_mm: parseFloat(techParams.lengthMm || 2000),
    nozzle_count: techParams.numNozzles || 0,
    weld_length_m: parseFloat(techParams.linearWeldLengthM || 0),
    weight_tons: parseFloat(techParams.structuralWeightTons || 1),
    material_cutting_factor: parseFloat(materialFactors.cuttingFactor),
    material_fitup_factor: parseFloat(materialFactors.fitupFactor),
    material_welding_factor: parseFloat(materialFactors.weldingFactor),
    material_ndt_factor: parseFloat(materialFactors.ndtFactor),
  };

  // Get applicable rules for selected scopes
  const scopeTypeCodes = selectedScopes.map(s => s.scopeType.code);

  const rules = await prisma.calculationRule.findMany({
    where: {
      isActive: true,
      scopeTypeCode: { in: scopeTypeCodes },
      OR: [
        { productType: project.productType },
        { productType: null }
      ],
      OR: [
        { materialCategory: materialFactors.category },
        { materialCategory: null }
      ],
      AND: [
        {
          OR: [
            { minThicknessMm: null },
            { minThicknessMm: { lte: params.thickness_mm } }
          ]
        },
        {
          OR: [
            { maxThicknessMm: null },
            { maxThicknessMm: { gte: params.thickness_mm } }
          ]
        }
      ]
    },
    orderBy: [{ priority: 'asc' }, { createdAt: 'asc' }]
  });

  let displayOrder = 0;

  // Apply each rule
  for (const rule of rules) {
    try {
      const ruleActivities = await applyRule(rule, params, project.id, displayOrder);
      activities.push(...ruleActivities);
      displayOrder += ruleActivities.length;
    } catch (error) {
      console.error(`Error applying rule ${rule.ruleCode}:`, error);
    }
  }

  // Save activities to database
  const createdActivities = [];
  for (const activity of activities) {
    try {
      const created = await prisma.activity.create({
        data: activity
      });
      createdActivities.push(created);
    } catch (error) {
      console.error('Error creating activity:', error);
    }
  }

  return createdActivities;
}

/**
 * Apply a single calculation rule
 */
async function applyRule(rule, params, projectId, startOrder) {
  const activities = [];

  // Check if rule requires nozzle iteration
  if (rule.activityCodePattern.includes('{nozzle_num}')) {
    const nozzleCount = params.nozzle_count || 0;

    for (let i = 1; i <= nozzleCount; i++) {
      const nozzleParams = { ...params, nozzle_num: i };

      const baseHours = evaluateFormula(rule.baseHoursFormula, nozzleParams);
      const difficultyFactor = calculateDifficultyFactor(rule, params, 'welding');
      const totalHours = (baseHours * 1 * difficultyFactor) / rule.defaultEfficiencyFactor;

      const activityCode = rule.activityCodePattern.replace('{nozzle_num}', String(i).padStart(3, '0'));
      const description = rule.activityDescriptionTemplate.replace('{nozzle_num}', `Nozzle ${i}`);

      activities.push({
        projectId,
        activityCode,
        description,
        scopeTypeCode: rule.scopeTypeCode,
        quantity: 1,
        unit: ActivityUnit.NOS,
        baseHours,
        difficultyFactor,
        efficiencyFactor: rule.defaultEfficiencyFactor,
        totalHours,
        crewSize: 2,
        durationDays: totalHours / 16,
        isAutoGenerated: true,
        isManualEdit: false,
        displayOrder: startOrder + activities.length
      });
    }
  } else {
    // Single activity rule
    const baseHours = evaluateFormula(rule.baseHoursFormula, params);
    const quantity = extractQuantity(rule, params);
    const activityType = getActivityType(rule.scopeTypeCode);
    const difficultyFactor = calculateDifficultyFactor(rule, params, activityType);
    const totalHours = (baseHours * quantity * difficultyFactor) / rule.defaultEfficiencyFactor;

    activities.push({
      projectId,
      activityCode: rule.activityCodePattern,
      description: rule.activityDescriptionTemplate,
      scopeTypeCode: rule.scopeTypeCode,
      quantity,
      unit: determineUnit(rule),
      baseHours,
      difficultyFactor,
      efficiencyFactor: rule.defaultEfficiencyFactor,
      totalHours,
      crewSize: determineCrewSize(rule.scopeTypeCode),
      durationDays: totalHours / (determineCrewSize(rule.scopeTypeCode) * 8),
      isAutoGenerated: true,
      isManualEdit: false,
      displayOrder: startOrder
    });
  }

  return activities;
}

/**
 * Safely evaluate a formula with parameters
 */
function evaluateFormula(formula, params) {
  try {
    // Replace parameter placeholders with values
    let expression = formula;

    // Handle ternary operators (simplified)
    expression = expression.replace(/\{(\w+)\}/g, (match, key) => {
      const value = params[key];
      return value !== undefined ? value : 0;
    });

    // Replace Math functions
    expression = expression.replace(/Math\.(\w+)/g, 'Math.$1');

    // Basic safety check - only allow math operations
    const safePattern = /^[\d\s+\-*/().,?:<>=!&|\w\s]+$/;
    if (!safePattern.test(expression)) {
      console.warn('Potentially unsafe formula:', formula);
      return 0;
    }

    // Create safe evaluation context
    const result = new Function('Math', `"use strict"; return (${expression})`)(Math);

    return isNaN(result) || !isFinite(result) ? 0 : Math.round(result * 100) / 100;
  } catch (error) {
    console.error('Formula evaluation error:', error, 'Formula:', formula);
    return 0;
  }
}

/**
 * Calculate difficulty factor based on parameters
 */
function calculateDifficultyFactor(rule, params, activityType) {
  let factor = parseFloat(rule.defaultDifficultyFactor);

  // Thickness penalty
  const thickness = params.thickness_mm;
  if (activityType === 'welding' || activityType === 'fitup') {
    if (thickness > 50) {
      factor *= 1.2;
    } else if (thickness > 100) {
      factor *= 1.4;
    }
  }

  return Math.round(factor * 100) / 100;
}

/**
 * Extract quantity from parameters based on rule
 */
function extractQuantity(rule, params) {
  switch (rule.scopeTypeCode) {
    case 'MAT_HANDLING':
    case 'MARKING':
    case 'PAINTING':
    case 'PACKING':
      return params.weight_tons || 1;
    case 'WELDING':
      return params.weld_length_m || 1;
    case 'NDT':
      return Math.ceil((params.weld_length_m || 0) / 0.5);
    case 'HYDROTEST':
      return 1;
    default:
      return 1;
  }
}

/**
 * Determine activity unit based on scope type
 */
function determineUnit(rule) {
  switch (rule.scopeTypeCode) {
    case 'MAT_HANDLING':
    case 'MARKING':
    case 'PAINTING':
    case 'PACKING':
      return ActivityUnit.KG;
    case 'WELDING':
      return ActivityUnit.METERS;
    case 'NDT':
      return ActivityUnit.NOS;
    case 'HYDROTEST':
    case 'HEAT_TREAT':
      return ActivityUnit.NOS;
    default:
      return ActivityUnit.HOURS;
  }
}

/**
 * Determine crew size based on scope type
 */
function determineCrewSize(scopeTypeCode) {
  switch (scopeTypeCode) {
    case 'MAT_HANDLING':
      return 3;
    case 'WELDING':
      return 2;
    case 'NDT':
      return 2;
    case 'HYDROTEST':
      return 4;
    default:
      return 2;
  }
}

/**
 * Get activity type from scope code
 */
function getActivityType(scopeTypeCode) {
  switch (scopeTypeCode) {
    case 'WELDING':
      return 'welding';
    case 'FITUP':
      return 'fitup';
    case 'NDT':
      return 'ndt';
    case 'MARKING':
      return 'cutting';
    default:
      return 'general';
  }
}

module.exports = {
  generateActivities,
  evaluateFormula
};
